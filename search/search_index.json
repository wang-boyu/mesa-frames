{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mesa-frames \ud83d\ude80","text":"<p>mesa-frames is an extension of the mesa framework, designed for complex simulations with thousands of agents. By storing agents in a DataFrame, mesa-frames significantly enhances the performance and scalability of mesa, while maintaining a similar syntax.</p> <p>You can get a model which is multiple orders of magnitude faster based on the number of agents - the more agents, the faster the relative performance.</p>"},{"location":"#why-dataframes","title":"Why DataFrames? \ud83d\udcca","text":"<p>DataFrames are optimized for simultaneous operations through SIMD processing. Currently, mesa-frames supports two main libraries:</p> <ul> <li>pandas: A popular data-manipulation Python library, known for its ease of use and high performance.</li> <li>Polars: A new DataFrame library with a Rust backend, offering innovations like Apache Arrow memory format and support for larger-than-memory DataFrames.</li> </ul>"},{"location":"#performance-boost","title":"Performance Boost \ud83c\udfce\ufe0f","text":"<p>Check out our performance graphs comparing mesa and mesa-frames for the Boltzmann Wealth model:</p> <p></p> <p></p>"},{"location":"#quick-start","title":"Quick Start \ud83d\ude80","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#installing-from-pypi","title":"Installing from PyPI","text":"<pre><code>pip install mesa-frames\n</code></pre>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<pre><code>git clone https://github.com/projectmesa/mesa-frames.git\ncd mesa_frames\npip install -e .\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Here's a quick example of how to create a model using mesa-frames:</p> <pre><code>from mesa_frames import AgentSetPolars, ModelDF\nimport polars as pl\n\nclass MoneyAgentPolars(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self += pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        # ... (implementation details)\n\nclass MoneyModelDF(ModelDF):\n    def __init__(self, N: int):\n        super().__init__()\n        self.agents += MoneyAgentPolars(N, self)\n\n    def step(self):\n        self.agents.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n</code></pre>"},{"location":"#whats-next","title":"What's Next? \ud83d\udd2e","text":"<ul> <li>API refinement for seamless transition from mesa</li> <li>Support for mesa functions</li> <li>Multiple other spaces: GeoGrid, ContinuousSpace, Network...</li> <li>Additional backends: Dask, cuDF (GPU), Dask-cuDF (GPU)...</li> <li>More examples: Schelling model, ...</li> <li>Automatic vectorization of existing mesa models</li> <li>Backend-agnostic AgentSet class</li> </ul>"},{"location":"#get-involved","title":"Get Involved! \ud83e\udd1d","text":"<p>mesa-frames is in its early stages, and we welcome your feedback and contributions! Check out our GitHub repository to get started.</p>"},{"location":"#license","title":"License","text":"<p>mesa-frames is available under the MIT License. See the LICENSE file for full details.</p>"},{"location":"development/","title":"Development Guidelines","text":"<p>Warning</p> <p>This page is in construction, check it again soon.</p>"},{"location":"user-guide/0_getting-started/","title":"Getting Started \ud83d\ude80","text":""},{"location":"user-guide/0_getting-started/#main-concepts","title":"Main Concepts \ud83e\udde0","text":""},{"location":"user-guide/0_getting-started/#dataframe-based-object-oriented-framework","title":"DataFrame-Based Object-Oriented Framework \ud83d\udcca","text":"<p>Unlike traditional mesa models where each agent is an individual Python object, mesa-frames stores all agents of a particular type in a single DataFrame. We operate only at the AgentSet level.</p> <p>This approach allows for:</p> <ul> <li>Efficient memory usage</li> <li>Improved performance through vectorized operations on agent attributes (This is what makes <code>mesa-frames</code> fast)</li> </ul> <p>Objects can be easily subclassed to respect mesa's object-oriented philosophy.</p>"},{"location":"user-guide/0_getting-started/#vectorized-operations","title":"Vectorized Operations \u26a1","text":"<p>mesa-frames leverages the power of vectorized operations provided by DataFrame libraries:</p> <ul> <li>Operations are performed on entire columns of data at once</li> <li>This approach is significantly faster than iterating over individual agents</li> <li>Complex behaviors can be expressed in fewer lines of code</li> </ul> <p>You should never use loops to iterate through your agents. Instead, use vectorized operations and implemented methods. If you need to loop, loop through vectorized operations (see the advanced tutorial SugarScape IG for more information).</p> <p>It's important to note that in traditional <code>mesa</code> models, the order in which agents are activated can significantly impact the results of the model (see Comer, 2014). <code>mesa-frames</code>, by default, doesn't have this issue as all agents are processed simultaneously. However, this comes with the trade-off of needing to carefully implement conflict resolution mechanisms when sequential processing is required. We'll discuss how to handle these situations later in this guide.</p> <p>Check out these resources to understand vectorization and why it speeds up the code:</p> <ul> <li>What is vectorization?</li> <li>Vectorization Explained, Step by Step</li> </ul> <p>Here's a comparison between mesa-frames and mesa:</p> mesa-framesmesa <pre><code>class MoneyAgentPolarsConcise(AgentSetPolars):\n    # initialization...\n\n    def give_money(self):\n        # Active agents are changed to wealthy agents\n        self.select(self.wealth &gt; 0)\n\n        # Receiving agents are sampled (only native expressions currently supported)\n        other_agents = self.agents.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n\n        # Wealth of wealthy is decreased by 1\n        self[\"active\", \"wealth\"] -= 1\n\n        # Compute the income of the other agents (only native expressions currently supported)\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        self[new_wealth, \"wealth\"] += new_wealth[\"len\"]\n</code></pre> <pre><code>class MoneyAgent(mesa.Agent):\n    # initialization...\n\n    def give_money(self):\n        # Verify agent has some wealth\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.agents)\n            if other_agent is not None:\n                other_agent.wealth += 1\n                self.wealth -= 1\n</code></pre> <p>As you can see, while in mesa you should iterate through all the agents' steps in the model class, here you execute the method once for all agents.</p>"},{"location":"user-guide/0_getting-started/#backend-flexibility","title":"Backend Flexibility \ud83d\udd04","text":"<p>mesa-frames aims to support multiple DataFrame backends: The supported backends right now are</p> <ul> <li>pandas: A widely-used data manipulation library</li> <li>Polars: A high-performance DataFrame library written in Rust</li> </ul> <p>Users can choose the backend that best suits their needs:</p> <pre><code>```python\nfrom mesa_frames import AgentSetPandas  # or AgentSetPolars\n```\n</code></pre> <p>Currently, there are two implementations of AgentSetDF and GridDF, one for each backend implementation: AgentSetPandas and AgentSetPolars, and GridPandas and GridPolars. We encourage you to use the Polars implementation for increased performance. We are working on creating a unique interface here. Let us know what you think!</p> <p>Soon we will also have multiple other backends like Dask, cuDF, and Dask-cuDF!</p>"},{"location":"user-guide/0_getting-started/#coming-from-mesa","title":"Coming from mesa \ud83d\udd00","text":"<p>If you're familiar with mesa, this guide will help you understand the key differences in code structure between mesa and mesa-frames.</p>"},{"location":"user-guide/0_getting-started/#agent-representation","title":"Agent Representation \ud83d\udc65","text":"<ul> <li>mesa: Each agent is an individual object instance. Methods are defined for individual agents and called on each agent.</li> <li>mesa-frames: Agents are rows in a DataFrame, grouped into AgentSets. Methods are defined for AgentSets and operate on all agents simultaneously.</li> </ul> mesa-framesmesa <pre><code>class MoneyAgentSet(AgentSetPolars):\n    def **init**(self, n, model):\n        super().**init**(model)\n        self += pl.DataFrame({\n            \"unique_id\": pl.arange(n),\n            \"wealth\": pl.ones(n)\n        })\n\n    def step(self):\n        givers = self.wealth &gt; 0\n        receivers = self.agents.sample(n=len(self.active_agents))\n        self[givers, \"wealth\"] -= 1\n        new_wealth = receivers.groupby(\"unique_id\").count()\n        self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"count\"]\n</code></pre> <pre><code>class MoneyAgent(Agent):\n    def **init**(self, unique_id, model):\n        super().**init**(unique_id, model)\n        self.wealth = 1\n\n    def step(self):\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.schedule.agents)\n            other_agent.wealth += 1\n            self.wealth -= 1\n</code></pre>"},{"location":"user-guide/0_getting-started/#model-structure","title":"Model Structure \ud83c\udfd7\ufe0f","text":"<ul> <li>mesa: Models manage individual agents and use a scheduler.</li> <li>mesa-frames: Models manage AgentSets and directly control the simulation flow.</li> </ul> mesa-framesmesa <pre><code>class MoneyModel(ModelDF):\n    def **init**(self, N):\n        super().**init**()\n        self.agents += MoneyAgentSet(N, self)\n\n    def step(self):\n        self.agents.do(\"step\")\n</code></pre> <pre><code>class MoneyModel(Model):\n    def **init**(self, N):\n        self.num_agents = N\n        self.schedule = RandomActivation(self)\n        for i in range(self.num_agents):\n            a = MoneyAgent(i, self)\n            self.schedule.add(a)\n\n    def step(self):\n        self.schedule.step()\n</code></pre>"},{"location":"user-guide/0_getting-started/#transition-tips","title":"Transition Tips \ud83d\udca1","text":"<ol> <li>Think in Sets \ud83c\udfad: Instead of individual agents, think about operations on groups of agents.</li> <li>Leverage DataFrame Operations \ud83d\udee0\ufe0f: Familiarize yourself with pandas or Polars operations for efficient agent manipulation.</li> <li>Vectorize Logic \ud83d\ude85: Convert loops and conditionals to vectorized operations where possible.</li> <li>Use AgentSets \ud83d\udce6: Group similar agents into AgentSets instead of creating many individual agent classes.</li> </ol>"},{"location":"user-guide/0_getting-started/#handling-race-conditions","title":"Handling Race Conditions \ud83c\udfc1","text":"<p>When simultaneous activation is not possible, you need to handle race conditions carefully. There are two main approaches:</p> <ol> <li> <p>Custom UDF with Numba \ud83d\udd27: Use a custom User Defined Function (UDF) with Numba for efficient sequential processing.</p> </li> <li> <p>Polars UDF Guide</p> </li> <li> <p>pandas Numba Engine</p> </li> <li> <p>Looping Mechanism \ud83d\udd01: Implement a looping mechanism on vectorized operations.</p> </li> </ol> <p>For a more detailed implementation of handling race conditions, please refer to the <code>examples/sugarscape-ig</code> in the mesa-frames repository. This example demonstrates how to implement the Sugarscape model with instantaneous growback, which requires careful handling of sequential agent actions.</p>"},{"location":"user-guide/1_classes/","title":"Classes \ud83d\udcda","text":""},{"location":"user-guide/1_classes/#agentsetdf","title":"AgentSetDF \ud83d\udc65","text":"<p>To create your own AgentSetDF class, you need to subclass the AgentSetPolars or AgentSetPandas class and make sure to call <code>super().__init__(model)</code>.</p> <p>Typically, the next step would be to populate the class with your agents. To do that, you need to add a DataFrame to the AgentSetDF. You can do <code>self += agents</code> or <code>self.add(agents)</code>, where <code>agents</code> is a DataFrame or something that could be passed to a DataFrame constructor, like a dictionary or lists of lists. You need to make sure your DataFrame has a 'unique_id' column and that the ids are unique across the model, otherwise you will get an error raised. In the DataFrame, you should also put any attribute of the agent you are using.</p> <p>How can you choose which agents should be in the same AgentSet? The idea is that you should minimize the missing values in the DataFrame (so they should have similar/same attributes) and mostly everybody should do the same actions.</p> <p>Example:</p> <pre><code>class MoneyAgent(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self.initial_wealth = pl.ones(n)\n        self += pl.DataFrame({\n            \"unique_id\": pl.arange(n),\n            \"wealth\": self.initial_wealth\n        })\n\n    def step(self):\n        self[\"wealth\"] = self[\"wealth\"] + self.random.integers(n)\n</code></pre> <p>You can access the underlying DataFrame where agents are stored with <code>self.agents</code>. This allows you to use DataFrame methods like <code>self.agents.sample</code> or <code>self.agents.group_by(\"wealth\")</code> and more.</p>"},{"location":"user-guide/1_classes/#modeldf","title":"ModelDF \ud83c\udfd7\ufe0f","text":"<p>To add your AgentSetDF to your ModelDF, you should also add it to the agents with <code>+=</code> or <code>add</code>.</p> <p>NOTE: ModelDF.agents are stored in a class which is entirely similar to AgentSetDF called AgentsDF. The API of the two are the same. If you try accessing AgentsDF.agents, you will get a dictionary of <code>[AgentSetDF, DataFrame]</code>.</p> <p>Example:</p> <pre><code>class EcosystemModel(ModelDF):\n    def __init__(self, n_prey, n_predators):\n        super().__init__()\n        self.agents += Preys(n_prey, self)\n        self.agents += Predators(n_predators, self)\n\n    def step(self):\n        self.agents.do(\"move\")\n        self.agents.do(\"hunt\")\n        self.prey.do(\"reproduce\")\n</code></pre>"},{"location":"user-guide/1_classes/#space-griddf","title":"Space: GridDF \ud83c\udf10","text":"<p>mesa-frames provides efficient implementations of spatial environments:</p> <ul> <li>Spatial operations (like moving agents) are vectorized for performance</li> </ul> <p>Example:</p> <pre><code>class GridWorld(ModelDF):\n    def __init__(self, width, height):\n        super().__init__()\n        self.space = GridPolars(self, (width, height))\n        self.agents += AgentSet(100, self)\n        self.space.place_to_empty(self.agents)\n</code></pre> <p>A continuous GeoSpace, NetworkSpace, and a collection to have multiple spaces in the models are in the works! \ud83d\udea7</p>"},{"location":"user-guide/2_introductory-tutorial/","title":"Introductory Tutorial: Boltzmann Wealth Model with mesa-frames \ud83d\udcb0\ud83d\ude80","text":"<p>In this tutorial, we'll implement the Boltzmann Wealth Model using mesa-frames. This model simulates the distribution of wealth among agents, where agents randomly give money to each other.</p>"},{"location":"user-guide/2_introductory-tutorial/#setting-up-the-model","title":"Setting Up the Model \ud83c\udfd7\ufe0f","text":"<p>First, let's import the necessary modules and set up our model class:</p> <pre><code>from mesa_frames import ModelDF, AgentSetPandas, AgentSetPolars\n\nclass MoneyModelDF(ModelDF):\n    def __init__(self, N: int, agents_cls):\n        super().__init__()\n        self.n_agents = N\n        self.agents += agents_cls(N, self)\n\n    def step(self):\n        self.agents.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n</code></pre> <p>This <code>MoneyModelDF</code> class will work for both pandas and Polars implementations.</p>"},{"location":"user-guide/2_introductory-tutorial/#implementing-the-agentset","title":"Implementing the AgentSet \ud83d\udc65","text":"<p>Now, let's implement our <code>MoneyAgentSet</code> using both pandas and Polars backends. You can switch between the two implementations:</p> pandas \ud83d\udc3cPolars \ud83d\udc3b\u200d\u2744\ufe0f <pre><code>    import pandas as pd\n    import numpy as np\n\n    class MoneyAgentPandas(AgentSetPandas):\n        def __init__(self, n: int, model: ModelDF) -&gt; None:\n            super().__init__(model)\n            self += pd.DataFrame(\n                {\"unique_id\": np.arange(n, dtype=\"int64\"), \"wealth\": np.ones(n)}\n            )\n\n        def step(self) -&gt; None:\n            self.do(\"give_money\")\n\n        def give_money(self):\n            self.select(self.wealth &gt; 0)\n            other_agents = self.agents.sample(n=len(self.active_agents), replace=True)\n            self[\"active\", \"wealth\"] -= 1\n            new_wealth = other_agents.groupby(\"unique_id\").count()\n            self[new_wealth.index, \"wealth\"] += new_wealth[\"wealth\"]\n</code></pre> <pre><code>    import polars as pl\n\n    class MoneyAgentPolars(AgentSetPolars):\n        def __init__(self, n: int, model: ModelDF):\n            super().__init__(model)\n            self += pl.DataFrame(\n                {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n            )\n\n        def step(self) -&gt; None:\n            self.do(\"give_money\")\n\n        def give_money(self):\n            self.select(self.wealth &gt; 0)\n            other_agents = self.agents.sample(n=len(self.active_agents), with_replacement=True)\n            self[\"active\", \"wealth\"] -= 1\n            new_wealth = other_agents.group_by(\"unique_id\").len()\n            self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"len\"]\n</code></pre>"},{"location":"user-guide/2_introductory-tutorial/#running-the-model","title":"Running the Model \u25b6\ufe0f","text":"<p>Now that we have our model and agent set defined, let's run a simulation:</p> <pre><code># Choose either MoneyAgentPandas or MoneyAgentPolars\nagent_class = MoneyAgentPandas  # or MoneyAgentPolars\n\n# Create and run the model\nmodel = MoneyModelDF(1000, agent_class)\nmodel.run_model(100)\n\n# Print the final wealth distribution\nprint(model.agents[\"wealth\"].describe())\n</code></pre> <p>Output:</p> <pre><code>count    1000.000000\nmean        1.000000\nstd         1.414214\nmin         0.000000\n25%         0.000000\n50%         1.000000\n75%         1.000000\nmax        13.000000\nName: wealth, dtype: float64\n</code></pre> <p>This output shows the statistical summary of the wealth distribution after 100 steps of the simulation with 1000 agents.</p>"},{"location":"user-guide/2_introductory-tutorial/#performance-comparison","title":"Performance Comparison \ud83c\udfce\ufe0f\ud83d\udca8","text":"<p>One of the key advantages of mesa-frames is its performance with large numbers of agents. Let's compare the performance of our pandas and Polars implementations:</p> <pre><code>import time\n\ndef run_simulation(model_class, n_agents, n_steps):\n    start_time = time.time()\n    model = model_class(n_agents)\n    model.run_model(n_steps)\n    end_time = time.time()\n    return end_time - start_time\n\n# Compare mesa and mesa-frames implementations\nn_agents_list = [100000, 300000, 500000, 700000]\nn_steps = 100\n\nprint(\"Execution times:\")\nfor implementation in [\"mesa\", \"mesa-frames (pl concise)\", \"mesa-frames (pl native)\", \"mesa-frames (pd concise)\", \"mesa-frames (pd native)\"]:\n    print(f\"---------------\\n{implementation}:\")\n    for n_agents in n_agents_list:\n        if implementation == \"mesa\":\n            time = run_simulation(MoneyModel, n_agents, n_steps)\n        elif implementation == \"mesa-frames (pl concise)\":\n            time = run_simulation(lambda n: MoneyModelDF(n, MoneyAgentPolarsConcise), n_agents, n_steps)\n        elif implementation == \"mesa-frames (pl native)\":\n            time = run_simulation(lambda n: MoneyModelDF(n, MoneyAgentPolarsNative), n_agents, n_steps)\n        elif implementation == \"mesa-frames (pd concise)\":\n            time = run_simulation(lambda n: MoneyModelDF(n, MoneyAgentPandasConcise), n_agents, n_steps)\n        else:  # mesa-frames (pd native)\n            time = run_simulation(lambda n: MoneyModelDF(n, MoneyAgentPandasNative), n_agents, n_steps)\n\n        print(f\"  Number of agents: {n_agents}, Time: {time:.2f} seconds\")\n    print(\"---------------\")\n</code></pre> <p>Example output:</p> <pre><code>---------------\nmesa:\n  Number of agents: 100000, Time: 3.80 seconds\n  Number of agents: 300000, Time: 14.96 seconds\n  Number of agents: 500000, Time: 26.88 seconds\n  Number of agents: 700000, Time: 40.34 seconds\n---------------\n---------------\nmesa-frames (pl concise):\n  Number of agents: 100000, Time: 0.76 seconds\n  Number of agents: 300000, Time: 2.01 seconds\n  Number of agents: 500000, Time: 4.77 seconds\n  Number of agents: 700000, Time: 7.26 seconds\n---------------\n---------------\nmesa-frames (pl native):\n  Number of agents: 100000, Time: 0.35 seconds\n  Number of agents: 300000, Time: 0.85 seconds\n  Number of agents: 500000, Time: 1.55 seconds\n  Number of agents: 700000, Time: 2.61 seconds\n---------------\n---------------\nmesa-frames (pd concise):\n  Number of agents: 100000, Time: 2.37 seconds\n  Number of agents: 300000, Time: 7.47 seconds\n  Number of agents: 500000, Time: 13.29 seconds\n  Number of agents: 700000, Time: 18.32 seconds\n---------------\n---------------\nmesa-frames (pd native):\n  Number of agents: 100000, Time: 1.63 seconds\n  Number of agents: 300000, Time: 5.76 seconds\n  Number of agents: 500000, Time: 9.48 seconds\n  Number of agents: 700000, Time: 13.58 seconds\n---------------\n</code></pre> <p>Speed-up over mesa: \ud83d\ude80</p> <pre><code>mesa-frames (pl concise):\n  Number of agents: 100000, Speed-up: 5.00x \ud83d\udca8\n  Number of agents: 300000, Speed-up: 7.44x \ud83d\udca8\n  Number of agents: 500000, Speed-up: 5.63x \ud83d\udca8\n  Number of agents: 700000, Speed-up: 5.56x \ud83d\udca8\n---------------\nmesa-frames (pl native):\n  Number of agents: 100000, Speed-up: 10.86x \ud83d\udca8\n  Number of agents: 300000, Speed-up: 17.60x \ud83d\udca8\n  Number of agents: 500000, Speed-up: 17.34x \ud83d\udca8\n  Number of agents: 700000, Speed-up: 15.46x \ud83d\udca8\n---------------\nmesa-frames (pd concise):\n  Number of agents: 100000, Speed-up: 1.60x \ud83d\udca8\n  Number of agents: 300000, Speed-up: 2.00x \ud83d\udca8\n  Number of agents: 500000, Speed-up: 2.02x \ud83d\udca8\n  Number of agents: 700000, Speed-up: 2.20x \ud83d\udca8\n---------------\nmesa-frames (pd native):\n  Number of agents: 100000, Speed-up: 2.33x \ud83d\udca8\n  Number of agents: 300000, Speed-up: 2.60x \ud83d\udca8\n  Number of agents: 500000, Speed-up: 2.83x \ud83d\udca8\n  Number of agents: 700000, Speed-up: 2.97x \ud83d\udca8\n---------------\n</code></pre>"},{"location":"user-guide/2_introductory-tutorial/#conclusion","title":"Conclusion \ud83c\udf89","text":"<ul> <li>All mesa-frames implementations significantly outperform the original mesa implementation. \ud83c\udfc6</li> <li>The Polars backend consistently provides better performance than the pandas backend. \ud83d\udc3b\u200d\u2744\ufe0f &gt; \ud83d\udc3c</li> <li>The native implementation for both Polars and pandas shows better performance than their concise counterparts. \ud83d\udcaa</li> <li>The Polars native implementation shows the most impressive speed-up, ranging from 10.86x to 17.60x faster than mesa! \ud83d\ude80\ud83d\ude80\ud83d\ude80</li> <li>Even the \"slowest\" mesa-frames implementation (pandas concise) is still 1.60x to 2.20x faster than mesa. \ud83d\udc4d</li> <li>The performance advantage of mesa-frames becomes more pronounced as the number of agents increases. \ud83d\udcc8</li> </ul>"},{"location":"user-guide/3_advanced-tutorial/","title":"Advanced Tutorial: SugarScape with Instantaneous Growback \ud83c\udf6c\ud83d\udd04","text":"<p>Work in Progress \ud83d\udea7</p> <p>This tutorial is coming soon! \ud83d\udd1c\u2728 In the meantime, you can check out the code in the <code>examples/sugarscape-ig</code> directory of the mesa-frames repository.</p>"},{"location":"user-guide/4_benchmarks/","title":"Performance Boost \ud83c\udfce\ufe0f\ud83d\udca8","text":"<p>mesa-frames offers significant performance improvements over the original mesa framework. Here are some benchmark results for different models:</p>"},{"location":"user-guide/4_benchmarks/#boltzmann-wealth-model","title":"Boltzmann Wealth Model \ud83d\udcb0","text":"<p>View the benchmark script</p>"},{"location":"user-guide/4_benchmarks/#comparison-with-mesa","title":"Comparison with mesa","text":""},{"location":"user-guide/4_benchmarks/#comparison-of-mesa-frames-implementations","title":"Comparison of mesa-frames implementations","text":""},{"location":"user-guide/4_benchmarks/#sugarscape-with-instantaneous-growback","title":"SugarScape with Instantaneous Growback \ud83c\udf6c","text":"<p>View the benchmark script</p> <p></p>"}]}